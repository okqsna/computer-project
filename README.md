# Бібліотека для роботи з графами 
### Комп'ютерний проєкт з дискретної математики 

<i>Підготували Юрій Фітьо, Катерина Сучок, Дарина Ничипорук, Юліан-Володимир Заєць, Оксана Москв'як</i>

Дана бібліотека опрацьовує отримані на вхід графи,
застосовує до них Гамільтоновий цикл, цикл Ейлера, <br>
перевіряє на двочастковість, перевіряє на ізоморфність 
та розфарбовує зв'язний граф у 3 кольори.

Детальніше кожну із функцій розглянуто нижче:


### Гамільтоновий цикл

#### Функція ``` check_for_ham ``` 
Ця програма перевіряє, чи має граф Гамільтоновий цикл, і відображає результати у вікні Tkinter, дозволяючи вводити графи у вигляді множин або кортежів.

```permute(nodes)``` Генерує всі перестановки списку вершин. 
```check_for_ham(graph) ``` Перевіряє наявністі гамільтонового циклу в графі.
```parse_input(text)``` Перетворює рядок у список або кортеж. 
```display_results(permutations, correct_path, indx=0)``` Виводить результати перевірки у прокручуваному полі в ткінтері 
```on_enter(event)``` Обробляє натискання клавіші Enter для запуску перевірки циклу
в ткінтерному форматі

<hr>

### Цикл Ейлера

Спершу йде перевірка на те, чи це орієнтований чи неорієнтований граф. Якщо він є неорієнтованим(ребра представлені множинами), то кожне ребро додається двічі та у додаткову змінну записується, що початковий граф неорієнтований.

### Рекурсивна функція ```calculate_way```.

Вона перебирає, всі можливі шляхи від початково заданої вершини. Так вона генерує шлях, або до моменту коли немає ребер, по яких можна рухатись далі, або коли вона не зустрічає початкову вершину. У цьому випадку вона перевіряє чи вона вже на даний момент містить всі ребра і, якщо ні, то продовжує рухатись далі. Якщо ж цей шлях охоплює всі ребра і закінчується в тій же вершині, звідки й виходив, то записує цей "цикл" до списку зі всіма можливи циклами.

Далі фунція повертає список зі всіх можливих циклів.

<hr>

### Двочастковість графу

#### Функція ``` bipartite_graph_check ``` перевіряє чи граф є двочастковим.

Основною ідеєю реалізації даної функції є використання <b>алгоритму пошуку в ширину (BFS)</b> та <b>розфарбовування вершин графа у два кольори</b> (тобто реалізація розділення вершин графа на 2 множини, у яких не повторюються вершини). 

Допоміжна функція ``` convert_to_directed ``` перетворює граф з неорієнтованого в орієнтований для подальшої роботи.

Допоміжна функція ``` get_neighbouring_values ``` знаходить для кожної вершини суміжні та повертає словник, де ключ це <b>вершина</b>, а значення - <b>множина суміжних вершин</b>.

На початку функція створює <b>“чергу”</b> ``` not_visited_vertices ``` для зафарбовування вершин із цієї черги та словник, який зберігає колір вершин. Імплементовано цикл ``` while ```, який працює поки черга не буде пустою. Для подальшої перевірки дістаємо першу вершину з черги, для якої відбувається перевірка чи не є ця вершина в відвіданих, далі відбувається перевірка суміжних до початкової вершин. Якщо поточна вершина та суміжна їй вершини однакового кольору - то цей граф <b>не двочастковий</b>, функція повертає значення - ``` False ```

Якщо всі вершини було зафарбовано без збігів, то граф <b>двочастковий</b>. Функція повертає значення - ``` True ```

<hr>

### Ізоморфність графу

#### Функція ```if_graphs_are_isomorphic``` перевіряє чи два графи є ізоморфними.

Допоміжні функції ```if_graph_is_directed``` і ```if_graph_is_undirected``` перевіряють чи графи <b>є орієнтованими, чи є неорієнтованими.</b>

Допоміжна функція ```directed_isomorphism``` перевіряє <b>ізоморфність</b> двох орієнтованих графів.

Алгоритм базується <b> на порівнянні структур графів шляхом перебору всіх можливих перестановок вершин.</b><br>
Спершу визначають списки вершин обох графів. Якщо кількість вершин у графах <b>відрізняється</b>, вони <b>не можуть</b> бути ізоморфними. Далі для кожної перестановки вершин перевіряється, чи відповідає структура одного графа структурі іншого, шляхом порівняння матриць суміжності або списків суміжності, враховуючи напрямки ребер. <br>
Алгоритм завершується та повертає ```True```, якщо знайдена відповідність, або повертає ```False``` після перевірки всіх можливих перестановок.

Допоміжна функція ```undirected_isomorphism``` перевіряє ізоморфність двох неорієнтованих графів.<br>

Алгоритм схожий до попередньої функції, але додатково <b>враховує симетричність</b> зв’язків між вершинами. Під час порівняння списків суміжності перевіряється, чи присутнє кожне ребро між вершинами в обох напрямках, оскільки у неорієнтованих графах порядок вершин у ребрі не має значення. Якщо <b>знаходиться перестановка</b>, яка забезпечує однаковість структур обох графів, вони вважаються <b>ізоморфними</b>; інакше — ні.

<hr>

###  Розфарбування зв'язного графу в 3 кольори

#### Функція ```to_matrix``` перетворює відношення на матрицю. 
Так як відношення задане у вигляді списку кортежів, легко створити заповнену нулями матрицю розміром максимального знайденого елементу у кортежіх списку, а потім присвоїти кожному елементу матриці значення 1(True) або 0(False) виразу, що перевіряє, чи існує кортеж з такими координатами в початковому списку. Матриця - список списків.

#### Функція ```to_symetric``` перетворює симетричну матрицю. 
Кожному елементу матриці присвоюється результат побітового або його із симетричним елементом.

#### Функція ```approp``` перевіряє, чи можна зафарбувати вершину конкретним кольором. 
На вхід отримуються номер вершини, матриця, список кольорів усіх вершин (за кольори сприймаються натуральні числа) та пропонований колір вершини (номер). Якщо жодна із сусідніх вершин не має цього кольору, то повертається 1 інакше 0. Сусідніми вершинами вважаються ті, що у матриці мають одинички у одному рядку чи стовпцю із опитуваною вершиною.

#### Функція ```colouring``` створює числовий список присвоєних кольорів.
На вхід функція отримує матрицю, її розмір, чисельний список присвоєних кольорів вершинам, кількість кольорів, що буде використовуватися, номер вершини, що буде зафарбовуватися. Ця функція рекурсивна і закінчуватиметься, коли ми дойдемо до останньої вершини, тому на початку відбувається перевірка на те, чи поточна вершина остання, якщо це правда по повертається True. Колір вершини визначаємо підбором, використовуючи для цього цикл. Всередині викликається ```approp```, якщо колір підходить, він записується у чисельний список. Далі ми викликаємо нашу функцію і перевіряємо чи вона повертає значенння True. По суті, в цьому моменті реалізовується рекурсія, яка закінчиться, коли ми дійдемо до останнього елементу. Коли це станеться, функція поверне заповнений чисельний список. Якщо ж у якісь вешині цикл дійде до кінця і не зможе підібрати жодного кольору, то функція поверне False.

#### Функція ```get_colour_seq``` об'єднує усі роботу усіх попередніх функцій та повертає стрічку з набором кольорів, або стрічку з повідомленням про неможливість розмальовування.
На вхід функція отримує назву файлу з графом із розширенням .dot та список кольорів, що ми можемо використовувати для розмальовування. Всередині функція створює симетричну матрицю, знаходить її розмір, формує заповнений нулями чисельний список для розмальовування розміром в кількість вершин, викликає функцію ```colouring``` та перевіряє чи вона не повертає нуль, тобто чи можна розмалювати граф таким чином. Якщо не можна, то у результат записується повідомлення: "The colouring is imposible.", інакше результат виклику функції зберігається та формується стрічка із списком кольорів через пробіл, яку функція повертатиме.

#### Функція ```write_colour``` створює новий файл, куди записує розмальований граф.
На вхід отримуються назви вхідного та вихідного файлу та список назв кольорів. Спочатку зберігається результат виклику функції ```get_color_seq```. Якщо ми отримали повідомлення про неможливість розмалювання, воно виводиться на екран, інакше відкриваються файли для читання та запису. Із вхідного у вихідний переписується все окрім останнього рядку, в якому записаний знак "}". Далі знаходиться їхня кількість і прописується опис кожної вершини, де вказується колір, який береться по порядку із отриманої стрічки.
